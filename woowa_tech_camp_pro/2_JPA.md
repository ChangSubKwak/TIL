## JPA
- 2021-11-06
  - 토크ON 41차. JPA 프로그래밍 기본기 다지기 T아카데미 1강 ~ 8강 수강
    - 3강 : 권장하는 식별자 전략에서 주민등록번호가 기본키로 적절하지 않은 이유를 확인할 수 있었음
      - 권장하는 키 설정 방법 : `Long + 대체키 + 키` 생성전략 사용
    - 5강 : 양방향 매핑에서 그동안 이해하기 어려웠던 mappedBy를 확실하게 이해할 수 있었음
      - 양방향 매핑 규칙은 객체의 두 관계중 하나를 연관관계의 주인으로 지정 하는 것이다.
      - 주인이 아닌쪽은 읽기만 가능, 주인은 mappedBy속성 사용 불가
      - 주인이 아니면 mappedBy 숙성으로 주인 지정
    - 6강 : JPA 내부구조
      - 비영속, 영속, 준영속, 삭제
      - 영속성 컨텍스트 이점 : 1차 캐시(트랜잭션동안 유효), 동일성 보장, 쓰기 지연, 변경 감지(스냅샷), 지연 로딩
      - JPQL 쿼리 실행시 플러시가 자동으로 호출됨
      - 플러시 : 영속성 컨텍스트를 비우지 않고 변경내용(쿼리)를 데이터베이스에 동기화
      - 프록시와 즉시로딩 주의 : 가급적 지연로딩 사용, 즉시 로딩 적용하면 예상하지 못한 SQL 발생, 즉시 로딩은 JPQL에서 N+1 문제 발생, @ManyToOne과 @OneToOne는 기본이 즉시로딩, @OneToMany, @ManyToMany는 기본이 지연로딩
    - 7강 : JPQL
      - 테이블이 아닌 객체 검색 쿼리
    - 8강 : Spring Data JPA와 QueryDSL
      - Spring Data JPA : 지루하게 반복되는 CRUD 문제를 세련된 방법으로 해결, 개발자는 인터페이스만 작성, 구현 객체를 동적 생성 주입
      - `JpaRepository<Object, Long>` 를 상속받아 사용
      - 메서드 이름으로 쿼리 생성
      - 이름만으로 검색 + 정렬 + 페이징 가능
      - QueryDSL : SQL, JPQL을 코드로 작성할 수 있도록 도와주는 빌더 API
        - SQL, JPQL은 문자, Type-check 불가능하여 해당 로직 실행 전까지 작동여부 확인 불가
        - 장점 : 문자가 아닌 코드로 작성, 컴파일 시점에 문법 오류 발견, 코드 자동완성, 단순하고 쉬움, 동적 쿼리
        - 동작원리 : Member.java -> APT -> QMember.java
      - 실무 경험 공유
        - 테이블 중심에서 객체 중심으로 개발 패러다임 변화
        - 유연한 데이터 베이스 변경 및 테스트 : JUnit 통합 테스트시 H2사용, 로컬에서 H2 DB서버 실행, 개발/운영은 mysql, oracle 사용
        - 테스트, 통합 테스트시에 CRUD는 믿고 간다.
      - 빠른 오류 발견 : 컴파일 시점, 어플리케이션 로딩 시점
      - 쿼리 문법과 관련된 오류발생은 거의 없으며, 비즈니스 로직 오류발생이 대부분
      - 생산성
        - 단순 코딩 시간 줄어듬 -> 개발 생선성 향상 -> 잉여 시간 발생
        - 비즈니스 로직 작성시 흐름 유지
        - 테스트 코드 작성 -> 리팩토링 가능

